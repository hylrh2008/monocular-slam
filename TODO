Semi-Dense Visual Odometry:
    ✔ Récupérer les images et remplir les structures RGBDPyramid @done (14-02-08 00:22)
    ✔ Tester une utilisation de dvo @done (14-02-08 00:22)
    ✔ Faire système de benchmark (Script Matlab + Tum utlis) @done (14-02-08 00:41)
    
    ☐ Faire ou copier un système simple de visualisation 3D temps réel.
    
    ✔ Ecrire la logique de matching stereo @done (14-03-01 01:46)
         ✔ Calculer ligne épipolaire a partir du déplacement @done (14-02-16 18:20)
         ✔ Calculer les estimations d'incertitudes @done (14-02-16 18:20)
           ✔ Geométrique @done (14-02-16 18:20)
           ✔ Photométrique @done (14-02-16 18:20)
           ✔ Conversion @done (14-02-16 18:20)
           ☐ Determiner les stddev des entrée: erreur sur l0 et erreur sur  l'intensité.
         ✔ Parcourir ces lignes @done (14-02-20 00:04)
         ✔ Calculer score SSD @done (14-02-16 18:21)
         ☐ Tester l'incertitude de triangulation
         ☐ Ecrire la logique de choix de l'image de référence

    ✔ Ecrire la logique de fusion bayésienne de l'information de profondeur @done (14-02-20 00:04)
         ☐ La tester avec une odometry "parfaite"
         ☐ La tester en vrai en série avec le tracking.
         ☐ En faire un autre thread?
   ☐ Régulariser la carte après la fusion
   ☐ Modifier l'algorithme d'odométrie pour prendre en entrée un poids par pixel déterminé (Sa covariance!)
   ☐ Optimiser ce qui peut l'être
   ✔ Paramétriser en inverse depth. @done (14-02-25 22:30)
   ✔ Gerer la propagation de la variance de facon plus précise @done (14-03-01 01:47)


     ☐ Ajout d'une mémoire d'age du pixel pour éviter de le rechercher dans une images trop vieille